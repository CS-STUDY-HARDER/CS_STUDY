# 물리 메모리
- 운영체제와 여러 작업들을 동시에 처리할때 메모리를 관리하는 방법은 메모리 관리 시스템(MMS)가 담당

---

## 메모리 관리의 이중성
- 프로세스의 작업 편리함과, 관리자의 관리 편리함의 충돌
- 운영체제가 어떻게 타협을 하는지가 관건

---

## 프로그램이 SSD가 아닌 메모리에서 실행하는 이유
- SSD는 빠르고 큰 저장장치지만, 메모리는 더 빠르지만 비싸서 작업 공간으로 사용한다
- 메모리를 계층적 구조로 만들어서 사용한다 (캐시 - 메모리 - 제2저장장치) (작업속도를 올리고, 가격을 낮춤)

### 컴파일러와 인터프린터
- 컴파일러는 실행전에 코드를 점검하여 오류 수정, 필요없는 부분 정리후 최적화된 실행 파일을 만듬
- 인터프리터는 한줄씩 위에서 아래로 실행
- 따라서 크고 복잡한 프로그램은 컴파일러 사용이 적합하고, 간단한 프로그램은 인터프리터가 적합

---

## MMU
- MMU(메모리 관리 유닛)은 메모리 관리자로, 가져오기, 배치, 재배치의 역할을 수행한다

### 가져오기
- 프로세스와 데이터를 메모리로 가져옴
- 일부만 가져와 실행할 수 도 있고, 앞으로 필요 예상되는것을 미리 가져올 수 도 있다

### 배치
- 프로세스와 데이터를 메모리의 어느곳에 올릴지 결정
- 메모리를 어떤 크기로 나눌지가 중요 (페이징, 세그먼테이션)

### 재배치
- 꽉찬 메모리에 새로운것을 가져오기 위해 일부 프로세스를 내보내는 작업

---

## 메모리 주소

### CPU의 비트
- 32비트와 64비트의 차이는 한번에 다룰 수 있는 데이터의 최대 크기의 차이이다
- 그러므로 CPU 내부 부품들은 해당 비트를 기준으로 제작
- 32비트의 경우 2^32개의 주소를 나타낼 수 있는데, 이는 메모리를 최대 4GB까지 사용가능하다
- 64비트의 경우 2^64의 CPU메모리를 사용가능 한데 이는 거의 무한대에 가깝다

### 절대주소와 상대주소
- 절대주소는 메모리 관리자 입장으로 물리 주소 0부터 시작
- 상대주소는 사용자 프로세스 입장으로 물리 주소와 상관없이 항상 0번지부터 시작
- 상대주소를 절대주소로 변환하는 과정이 필요 (메모리 관리자가 재배치 레지스터를 통해 빠르게 처리함)

---

## 단일 프로그래밍에서 메모리 할당
### 메모리 오버레이
- 프로그램이 실행되면 필요한 모듈만 메모리에 올라와 실행
- 메모리보다 더 큰 프로그램 실행 가능

### 스왑
- 다른 모듈을 가져올때 먼저 메모리에 올라온 모듈을 보관
- 메모리가 부족해 나온 프로세스는 저장공간의 스왑영역에 보관
- 하드디스크와 같은 저장장치는 저장장치 관리자가 관리하지만, 스왑 영역은 저장장치가 장소만 빌려주고, 메모리 관리자가 관리
- 이를 통해 사용자는 실제 메모리 크기 + 스왕 영역 크기를 전체 메모리로 인식 (실제 메모리 크기로만 이루어진것 보다는 속도가 느리지만, 부족한 크기 보충 가능)

---

## 다중 프로그래밍에서 메모리 할당
- 각 프로세스의 크기가 달라 메모리를 어떻게 나누는지가 관건

### 가변 분할 방식
- 한 프로세스가 연속된 공간에 배치
- 프로세스의 크기에 맞게 메모리 분할
- 가상 메모리 시스템에서는 세그먼테이션 기법이라고 한다
- 빈 영역이 충분히 있어도 서로 떨어져 있으면 프로세스를 배정하지 못하는 빈공간이 생기는 외부 단편화 발생
- 조각모으뫄 같은 추가적인 작업이 필요하여 관리가 복잡

### 고정 분할 방식
- 한 프로세스가 분산되어 배치
- 프로세스의 크기에 상관 없이 같은 크기로 분할
- 가상 메모리 시스템에서는 페이징 기법이라고 한다
- 프로세스를 메모리 조각에 배치하고 메모리 공간이 남는 내부 단편화가 발생
- 파티션 크기를 줄이면 내부 단편화가 줄지만, 여러개 분할이 발생하여 관리가 어렵고, 파티션을 늘리면 내부 단편화가 늘어나서 크기 결정이 중요

### 버디 시스템 방식
- 가변 분할과 고정 분할의 중간 구조


---
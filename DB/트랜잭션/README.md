# 트랜잭션

---

## 트랜잭션이란
- DB의 데이터를 다루는 작업의 단위
- 장애 발생시 복구하는 작업의 단위
- 여러 작업이 동시에 같은 데이터를 다룰때 작업을 분리하는 단위
- DBMS가 트랜잭션 규칙을 지킬 수 있도록 지원

## 트랜잭션의 성질
- DB의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성 (ACID)의 성질을 가짐
- 원자성
    - 포함된 작업이 전부 수행 or 전부 수행되지 않음
- 일관성
    - 트랜잭션 전, 후로 DB는 항상 일관된 상태를 유지
- 고립성
    - 다른 트랜잭션이 끼어들어 데이터 훼손이 없어야함
- 지속성
    - 수행 완료된 트랜잭션은 영구히 저장

### 원자성
- 중간에 잘못되면 변경한 내용을 취소한다 (ROLLBACK)
- 트랜잭션의 길이가 길때 중간에 세이브 포인트를 만들어서, 트랜잭션이 잘못될때 세이브 포인트까지 되돌아가는 방법으로 전체 롤백을 막을 수 있다
- 세이브 포인트는 여러개 만들 수 있다

### 일관성
- 테이블이 생성될 때 CREATE문, ALTER문의 무결성 제약조건을 통해 명시
- 데이터 변경시 미리 정의해 둔 무결성 제약조건을 검사해 일관성이 꺠지는것을 막는다

### 고립성
- 동시에 수행되는 트랜잭션이 충돌하지 않도록 하는 동시성 제어
- 트랜잭션 고립 수준에 따라 동시성 제어보다 완화된 방법으로 사용할 수 있다

### 지속성
- DBMS 복구 시스템은 작업 내용을 수시로 로그 DB에 기록하여 이를 통해 복구 수행. 그러므로 시스템이 멈춰도 트랜잭션 수행 변경 내용은 디스크에 기록된다
- 트랜잭션은 부분완료 또는 실패 상태가 되는데 부분완료는 DB에 내용을 반영하고, 실패 상태는 내용을 취소한다
- 부분완료에서 시스템 문제로 DB에 기록하지 못하면 실패 상태로 된다

## 트랜잭션 수행 방법

### 트랜잭션 문법

- START TRANSACTION과 COMMIT으로 트랜잭션의 시작과 끝을 나타낸다

```sql
START TRANSACTION

... 문장1
... 문장2

COMMIT
```
- 위의 예제의 문장1과, 문장2는 하나의 논리적인 작업 단위가 된다

### 트랜잭션 원리
- DB에 저장된 테이블을 읽어서 주기억장치 버퍼에 저장하고, 버퍼의 데이터를 수정한뒤 DB에 다시 저장하는 과정을 통해 트랜잭션이 일어난다
- DB의 데이터는 하드디스크에 저장되어 있지만, 처리를 위해서는 주기억장치 버퍼로 사본을 읽어와야 한다
- DBMS가 일괄적으로 하드디스트에 접근해서 처리하여 빠른 응답을 하기 위해서 하드디스크에 접근하기 전까지 수행한뒤 사용자에게 완료 사실을 알려준다.
    - DB에 기록하는 과정이 시간이 많이 소요되고, 다른 트랜잭션이 해당 테이블을 필요 할 수 있기 때문
    - 시작 - 수행 - 부분완료(트랜잭션 종료롤 이때 알림) - 버퍼내용기록 - 완료
    - 부분완료된 트랜잭션은 다른 트랜잭션의 작업 상황을 확인하면서 하드디스크에 기록한다

## 동시성 제어
- 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어

### 갱신손실 문제
- 두개의 트랜잭션이 하나의 데이터를 동시 갱신할때 발생
#### 락
- 갱신손실 문제 해결 방법
- 데이터 수정 중이라는 사실을 알림
- 동시 접속이 많을때 응답시간에 영향이 커지는 단점
- 공유락
    - 트랜잭션이 읽기를 할때 사용하는 락
- 배타락
    - 읽기,쓰기를 할때 사용하는 락

#### 2단계 락킹
- 락을 걸었다 풀고 다시 거는 과정에서 락의 해지상태가 발생하는데, 이를 방지하기 위해 2단계 락킹을 사용
- 트랜잭션1이 쓰기 작업중인 데이터를 트랜잭션2가 작업하는것을 방지
- 트랙잭션이 작업을 완료하기 전 락을 해재하지 않는 방법

- 확장단계
    - 락을 획득하는 단계
    - 이미 획득한 락은 해제하지 않음
- 수축단계
    - 락을 해제하는 단계
    - 새로운 락을 획득하지 않음

- 확장단계에서는 락을 걸기만 하고, 수축단계 에서는 락을 해지만 함

- 2단계 락킹에서는 데드락이 발생할 수 있음
    - 데드락 발생시 작업하나를 강제 중지하면 나머지 트랜잭션은 정상 실행
    - 중지한 트랜잭션은 원래 상태로 되돌림
    - 대기 그래프로 데드락 판단 가능 (그래프의 사이클 판단)

## 트랜잭션 고립 수준
- 읽기만 하는 트랜잭션은 심각한 문제가 발생하지 않지만, 읽기만 하는 트랜잭션이 쓰기 트랜잭션의 중간 데이터를 읽을때 문제가 발생

### Dirty Read
- dirty read는 읽기 작업이 쓰기 작업의 중간 데이터를 읽기 때문에 발생. 쓰기 데이터가 롤백하면 트랜잭션1은 롤백전의 데이터를 읽게 되는 결과

### Non-Repeatable Read
- Non-Repeatable Read는 트랜잭션 1이 읽고, 트랜잭션 2가 쓰고, 트랜잭션 1이 다시 읽을때 이전의 결과가 반복되지 않는 현상

### Phantom Read
- 트랙잭션 1이 읽고, 트랜잭션 2가 쓰고 트랜잭션 1이 다시 읽을때 이전에 없던 데이터가 나타나는 현상
- Non-Repeatable Read 처럼 같은 SQL문이 다른 결과 도출

### READ UNCOMMITTED (레벨 0)
- Dirty Read(O) Non-Repeatable Read(O) Phantom Read(O)
- 다른 트랜잭션이 commit하지 않은 데이터도 읽을 수 있음

### READ COMMITTED (레벨1)
- Dirty Read(X) Non-Repeatable Read(O) Phantom Read(O)
- 자신의 데이터를 읽는 동안 공유 락을 걸지만 트랜잭션이 끝나기 전에도 해지 가능
- 공유락은 읽지만 배타락을 읽지 못함

### REPEATABLE READ (레벨2)
- Dirty Read(X) Non-Repeatable Read(X) Phantom Read(O)
- 공유락과 배타락을 트랜잭션이 종료할 때 까지 유지하여 다른 트랜잭션 유지 방지
- 동시성이 맞아서 특별한 사항이 아니라면 권장하지 않음

### SERIALIZABLE (레벨3)
- Dirty Read(X) Non-Repeatable Read(X) Phantom Read(X)
- 다른 트랙잭션으로부터 완벽한 분리
- SELECT 대상 테이블에 미리 배타락 설정과 같은 효과
- 다른 트랜잭션의 INSERT문 금지

## 회복
- DB에 문제가 발생했을때 일관성 있는 상태로 되돌리는 기능
- 트랜잭션은 버퍼를 로그에 기록후 DB에 반영하는데, 문제 발생시 이 로그를 참조하여 모두 반영하거나 모두 반영하지 않는 방법으로 원자성과 지속성을 보장한다
- 부분완료에 도달하면 변경된 데이터는 모두 로그파일에 기록되어 있다

### REDO
- 문제 발생 이후 로그 파일에 트랜잭션 시작과 종료가 있는 경우 로그를 보면서 DB에 다시 기록하는 과정

### UNDO
- 문제 발생 이후 로그 파일에 트랜잭션 시작만 있을때 종료가 없는것은 트랜잭션이 완료하지 못한것이므로 한일을 모두 취소하여 원상복구 

### 즉시갱신
- 버퍼 -> 로그파일, 버퍼 -> DB 작업이 부분완료 전에 동시에 진행될 수 있어서, 부분완료 전에 버퍼의 일부 내용이 실제 DB에 반영될수 있어서 DB원상복구가 필요할수 있음

### 지연갱신
- 버퍼 -> 로그파일 작업이 모두 완료된뒤 부분완료 후 버퍼->DB 작업을 진행
- DB 반영은 지연되지만, 장애 발생시 로그에 시작만 있는 트랜잭션은 UNDO하지 않아도 된다(DB에 실제 반영된 내용이 없으므로)

### 체크 포인트 회복
- 체크 포인트 지점을 만들어 어느 지점으로 돌아갈지 나타냄
- 체크포인트는 DB와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그파일에 기록한 시점

#### 체크포인트 이전 commit기록 O
- 아무 작업이 필요 없음

#### 체크포인트 이후 commit기록 O
- 체크 포인트 이후 변경 내용이 DB에 반영되지 않았을 수 있어서 REDO 진행

#### 체크포인트 이후 commit기록 X
- 즉시갱신시 버퍼의 내용이 반영됐을 수 있어서 UNDO로 원상복구
- 지연갱신시 COMMIT이전에 DB에 반영하지 않기 때문에 아무것도 하지 않음

---
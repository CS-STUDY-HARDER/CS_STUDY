# 데이터베이스

---
## 데이터베이스가 없으면 무엇이 곤란한가?

1. 대량의 데이터 중에서 필요한 것을 빨리 반환할 수 없다.
2. 대량의 데이터를 메모리 내에서만으로 취급할 수 없다.
3. 장애가 발생했을 때 빠른 복구가 어렵다.
4. 병렬성 제어가 어렵다.
5. 데이터 무결성을 보장하는 것이 어렵다.

---

## 인덱스

### 인덱스와 B-tree
데이터베이스에서 인덱스란 원하는 데이터를 빨리 찾기 위해 투플의 키 값에 대한 물리적 위치를 기록해둔 자료구조

#### B-tree
- 데이터의 검색 시간을 단축하기 위한 자료구조 
- 루트노드, 내부노드, 리프노드로 구성되어 리프노드가 모두 같은 레벨에 존재하는 균형트리 
- 하나의 노드에 여러개가 배치될 수 있다. 
- 각 노드는 키 값과 포인터를 가지며, 키 값은 오름차순으로 저장되어 있고 키 값 좌우에 있는 포인터는 각각 키 값보다 작은 값과 큰 값을 가진 다음 노드를 가리킨다. 
- 모든 검색은 루트 노드에서부터 시작하여 내부 노드를 지나 리프 노드까지 내려가면서 이루어진다. 
- 키 값이 새로 추가되거나 삭제될 경우 동적으로 노드를 분할하거나 통합하여 항상 균형 상태를 유지한다. 
- 삽입될 위치의 노드에 저장할 공간이 없으면 새로운 노드를 분할하여 이동하여 삽입한다.
- B-tree의 삽입과정 [https://www.youtube.com/watch?v=MpYRkCsP2PQ](https://www.youtube.com/watch?v=MpYRkCsP2PQ)
- 데이터의 변경이나 추가가 잦을 경우 노드의 분할 및 이동이 자주 발생하는 문제가 생긴다.

#### 인덱스의 특징
- 인덱스는 테이블에서 한 개 이상의 속성을 이용하여 생성한다.
- 빠른 검색, 효율적인 레코드 접근이 가능하다.
- 순서대로 정렬된 속성과, 데이터의 위치만 보유하므로 테이블보다 작은 공간 차지
- 일반적으로 B-tree형태

### MySQL 인덱스
MySQL의 인덱스는 클러스터 인덱스와 보조 인덱스로 나누어지며 모두 B-tree 인덱스를 기본으로 한다. <br>
클러스터 인덱스는 연속된 키 값의 레코드를 묶어서 같은 블록에 저장하는 방법으로 테이블당 하나만 생성할 수 있고, B-tree 인덱스의 리프노드에서 페이지의 주소 값 대신 테이블의 열 자체가 저장된다. <br>
보조 인덱스는 속성의 값으로 B-tree 인덱스를 구성하며 리프 노드의 각 행은 해당 페이지의 주소값을 저장한다.

#### 클러스터 인덱스
클러스터 인덱스는 인덱스의 리프 노드들이 정렬된 상태로 저장된 테이블 자체. <br>
키 값에 의한 동등 및 범위(BETWEEN) 검색 모두 유리하다.
인덱스 페이지가 단순해져 인덱스 저장시 차지하는 공간도 작다. <br>
테이블 생성시 기본키를 생성하면 자동으로 생성된다. <br>

#### 보조 인덱스
리프노드는 테이블상의 데이터 위치를 지정하는 rowid를 저장한다. <br>
rowid는 (Block번호, Block내의 Row가 위치한 순번)의 형태로 구성되어 있어서 자료가 무작위로 저장되어 있어도 쉽게 찾을 수 있다. <br>
컬럼 하나만을 대상으로 단일 컬럼 인덱스뿐만 아니라, 여러 개의 컬럼을 복합적으로 결합하여 사용하는 인덱스도 만들 수 있다. <br>
검색할 경우 특정 키 값을 찾는 검색의 경우는 성능을 보장할 수 있으나, 범위 검색은 데이터가 저장된 block 값들의 저장 순서가 일정하지 않을 수 있어서 빠른 검색 효과를 보장할 수 없다.

#### MySQL 인덱스
클러스터 인덱스와 보조 인덱스는 보통 같이 사용된다. <br>
예를 들어 id를 클러스터 인덱스로, name을 보조 인덱스로 사용하여 id를 검색할 경우 클러스터 인덱스를 이용하고, name을 검색할 경우 보조 인덱스를 이용하여 id를 찾은 다음 다시 id에 대해 클러스터 인덱스를 사용한다. 이렇게 하는 이유는 클러스터 인덱스로 저장된 데이터의 순서를 가능한 유지하면서 데이터의 삽입과 삭제에 대한 인덱스 관리 비용을 줄이기 위해서이다. <br>
기본키를 지정하면 기본 키에 대하여 클러스터 인덱스를 생성하고, 기본키를 생성하지 않으면 먼저 나오는 UNIQUE 속성에 대하여 클러스터 인덱스를 생성한다. 기본키나 UNIQUE 속성이 없는 테이블은 MySQL이 자체 생성한 행번호를 이용하여 클러스터 인덱스를 생성한다. <br>
클러스터 인덱스가 아닌 모든 인덱스는 보조 인덱스이며 보조 인덱스의 각 레코드는 보조 인덱스 속성과 기본키 속성 값을 갖고 있다. <br>
MySQL이 생성된 인덱스를 활용하여 SQL문을 처리하는지 확인하려면 MySQL Work bench의 실행 계획에서 인덱스를 활용하여 출력하는 과정을 볼 수 있다. <br>

#### 인덱스 생성
인덱스 생성시 고려사항
1) WHERE절에 자주 사용되는 속성이어야 한다
2) 조인에 자주 사용되는 속성이어야 한다
3) 단일 테이블에 인덱스가 많으면 속도가 느려질 수 있다 (테이블당 4~5개 정도 권장)
4) 속성이 가공되는 경우 사용하지 않는다
5) 속성의 선택도가 낮을 때 유리하다 (속성의 모든 값이 다른 경우)

<br>
인덱스 생성 문법 <br>

```sql
CREATE [UNIQUE] INDEX [인덱스이름] ON 테이블이름 (컬럼 [ASC | DESC] [{, 컬럼 [ASC | DESC]} ...])[;]
```

<br>
인덱스 재구성 문법 <br>
B-tree 인덱스는 데이터의 수정, 삭제, 삽입이 잦으면 노드의 갱신이 주기적으로 일어나 단편화 현상이 나타나는데, 이럴 경우 ANALYZE 문법을 통해 인덱스를 다시 생성해준다. <br>

```sql
ANALYZE TABLE 테이블이름;
```

<br>
인덱스 삭제 문법 <br>

```sql
DROP INDEX  인덱스이름 ON 테이블이름;
```

--- 

## 인덱스로 고속 액세스 실현하기

### 전체 검색은 대량의 데이터에 적합하지 않다

사용자 정보를 텍스트 파일로 관리하는 경우, 확인을 위해 파일을 처음부터 찾을 때까지 탐색해야 한다. 이 선형 검색은 검색 알고리즘에서 가장 비효율적인 것이고 적절한 방법이 아니다.

### 원하는 위치까지 순식간에 도달하는 방법 생각하기

고정 길이 파일로 관리하면 특정 위치로 이동하는 작업이 순식간에 가능하지만, 빈 공간의 데이터가 많아져 낭비가 심한 방식이다.

### 해시 인덱스

키 값의 데이터 항목은 숫자, 문자열, 날짜/시간 등 이므로 범용성을 생각하면 고정 길이가 어렵다. 데이터베이스 구현은 키 값을 해시함수에 대입하여 해시 값과 값의 쌍을 갖는 구조로 사용한다. 이러한 인덱스를 해시 인덱스라고 한다. 해시 값은 동일한 크기이므로 고정 길이 포맷으로 대응할 수 있고, 해시 계산 비용은 데이터의 양이 늘어도 변하지 않는다.

해시 인덱스를 구현할 때 다른 키 값인데 해시 값이 동일하게 되는 해시의 충돌이 있는데, 데이터베이스에서는 이를 방지하는 기능을 가지고 있어 데이터의 양이 증가하면 평균 처리 속도는 증가하지만, 전체 검색과는 비교도 안 될 정도로 고속이다.

### 해시 인덱스는 만능이 아니다

데이터베이스에서 다음과 같은 처리는 수시로 이뤄지는데, 해시 인덱스를 다음 목적으로 사용할 수 없다.

1. 가격이 10,000원 이하의 선물을 찾고 싶다.
2. 제목이 “Final”로 시작하는 게임 리스트를 찾고 싶다.
3. 일기 포스팅 시간이 최신 순으로 정렬하고 싶다.

해시 인덱스는 지정한 키 값과 같은 것밖에 찾을 수 없기 때문에 이러한 목적으로 사용할 수 없다. 위 용도로 빠르게 결과를 반환하는 방법은 B+Tree 인덱스 구조를 사용하는 것이다.

---

## 인덱스의 기본 B+Tree 인덱스

### B+Tree 인덱스란?

B+Tree는 루트 블록, 브랜치 블록, 리프 블록이 들어간다. 루트 블록과 브랜치 블록은 검색의 키인 사용자 ID에 대해 해당 블록이 어디에 있는지에 대한 정보를 가지고 있다. 최하층 리프 블록은 실제 저장 위치의 정보를 가지고 있다. 인덱스 검색 시 루트 → 브랜치 → 리프 순으로 도달하여 원하는 데이터를 얻을 수 있다.

![B+Tree 검색](images/B+Tree%20Search.png "B+Tree 검색")

위 예에서 루트를 읽음으로써 브랜치2를 읽으면 되는 것을 알 수 있고, 리프 170을 읽으면 되는 것을 알 수 있다. 루트 1회, 분기 1회, 리프 1회, 실제 데이터의 총 4회로 접근해 원하는 사용자 정보를 얻을 수 있다.

### B+Tree와 B-Tree

BTree 인덱스는 여러 종류가 있지만, RDBMS는 끝단의 리브 볼록에서만 값을 관리하는 B+Tree가 가장 많이 사용된다.

B-Tree는 모든 값을 리프 블록에서만 갖도록 제한하지 않고, 브랜치에서도 값을 가질 수 있는 데이터 구조다.

B+Tree는 B-Tree 보다 브랜치가 컴팩트하므로 인덱스 자체의 계층 구조를 작게 할 수 있다는 장점이 있다. 이는 최악의 경우 액세스 횟수를 줄인다는 것을 의미한다.

보통의 B-Tree는 브랜치에서도 키 정보를 가지고 있다. 따라서 주변의 리프가 아닌 브랜치로 되돌아가 값의 존재 확인을 하고 상위 브랜치로 가거나 다른 리프로 가는 등의 처리를 해야하지만, B+Tree 인덱스는 리프 블록에서 인접한 리프 블록으로 건너는 것만으로 탐색이 가능하기 때문에 더욱 효율적이다.

--- 

## **RDBMS에서는 어떻게 최적화를 실현하고 있는가?**

### 고유성의 보장

인덱스는 고유성을 보장하는 목적으로 사용할 수 있다. 해시 인덱스는 동일 ID인 경우 해시값이 동일하고, B+Tree 인덱스는 동일 리프 블록에 도달하기 때문에 쉽게 중복 체크를 할 수 있다.

고유성이 보장된 인덱스를 고유 인덱스 보장되지 않은 인덱스를 비고유 인덱스라고 한다. 데이터베이스 서버에서는 고유성을 보장하려는 열에 인덱스를 지정하는 것이 필수 조건으로 되어 있거나 내부적으로 인덱스를 작성하는 것이 대부분이다.

### 멀티 칼럼 인덱스

인덱스 검색을 하는 데 있어 지정하고 싶은 조건이 한 개뿐은 아니다. 예를 들어 “사용자 ID가 100이고 마지막 수정 날짜가 2009년 9월 30일 이전의 것”, 이 경우 사용자 ID와 최종 업데이트 모두 검색하는 것이 효과적이다. 이러한 여러 조건의 인덱스를 멀티 칼럼 인덱스라고 한다.

대부분의 RDBMS는 두 가지 요소를 결합한 인덱스를 만들 수 있고, AND 조건에서 검색을 가속화 할 수 있다.

### 인덱스만을 읽는 검색

인덱스 검색은 먼저 인덱스를 읽은 후에 인덱스가 가리키는 데이터 영역을 읽는 두 단계이다. 인덱스 부분과 데이터 부분은 서로 독립적 영역에 존재해 양쪽을 한 번의 액세스로 단번에 읽을 수 없다.

검색 패턴에 따라 인덱스를 읽는 것만으로 처리가 되는 경우도 있다. 예를 들어 “가격이 10,000원 이하인 상품의 개수를 알고 싶다”의 경우에는 가격 인덱스가 있으면 “가격 ≤ 10,000”의 조건에 맞는 레코드 건수를 열거하는 것만으로 결과를 구하므로 데이터 영역에 액세스 할 필요가 없다. 이렇게 인덱스 영역을 읽는 것만으로 처리를 고속으로 완료하는 것을 Index only read, Convering Index 라고 부른다.

### 인덱스 병합

“부서 코드가 100번 또는 입사 연도가 2010년인 직원을 찾고 싶다”라는 경우 OR 조건의 검색은 하나의 인덱스만으로 검색에 도움이 안된다. 그래서 한 번의 두 개 이상의 인덱스를 동시에 사용하여 각각의 결과에서 원하는 레코드를 꺼내는데 이러한 기능을 인덱스 병합이라고 한다.

인덱스 병합은 각 인덱스에서 각각 검색을 실시해 대상의 행 번호를 추출한다. 그 다음 각 결과의 대해 AND 조건과 OR 조건 등으로 집합 연산을 수행하고, 마지막으로 남은 행 번호에 대해 실제 데이터를 읽어 가는 효율적인 동작을 한다.

---

## 데이터 모델링 기술의 중요성 

애플리케이션을 만들 때 중요한 것이 바로 “어떤 데이터 항목이 필요한가”를 제대로 파악하는 것이다. 항목이 부족하면 나중에 추가할 수도 있지만, 이는 대부분의 경우 애플리케이션의 개선이 필요하고 가동 후에 실시하는 것이 쉽지 않기 때문이다.

어떤 항목이 필요한지를 적절히 결정하는 데에는 “데이터를 어떻게 사용하느냐”라는 “업무 요구사항”이 명확하게 있어야 한다. 기능 추가가 자주 발생하는 애플리케이션에서 데이터 항목을 완벽히 미리 밝혀내는 것은 불가능하기 때문에 나중에 손쉽게 추가할 수 있는 디자인도 중요하다.

- 직원은 고유의 사원 번호를 가진다.
- 같은 이름의 사원이 있는 경우가 있다.
- 이름의 한자가 다르다 해도 발음이 같은 직원이 있는 경우가 있다.
- 직원은 메일 주소가 부여된다. 메일 주소는 중복되지 않는다.
- 경력 사원 등 수속 절차에 따라 메일 주소의 부여가 지연될 수 있으며, 이 경우는 당분간 메일 주소가 없는 상태가 된다.
- 직원은 어느 부서에 반드시 소속된다.
- 부서 이름이 중복될 수 없다.
- 부서 전화번호가 가지각색이므로 이것도 관리하고 싶다.

### 전통적 방법의 테이블 생성

테이블은 행과 열로 구성되는데 행에는 직원을 넣고 열에는 키워드를 모아 둔다. 테이블 설계에서 행을 고유하게 식별하기 위해 식별자를 도입하는 것이 일반적이다. 이것을 기본 키라고 하며, 기본 키가 없을 경우 어떤 레코드에 문제가 있는지를 확인할 경우에 해당 레코드가 단지 하나뿐이라고 보증할 수 없다.

| emp_id | emp_name | emp_roman | emp_email | dept_name | dept_tel |
| --- | --- | --- | --- | --- | --- |
| 1 | 기리조 | Krijo | Krijo@... | 인사부 | 03-12 |
| 2 | 유카리 | Yukari | Yukari@.. | 인사부 | 03-12 |
| 3 | 치에 | Chie | Chie@... | 경리부 | 03-34 |

이 테이블의 문제점은 같은 값을 가지는 부서 이름, 부서 전화번호가 곳곳에 나온다는 것이다. 중복이 수십 개에 달하고 앞으로 어떻게 될지가 잘 안보이면 동일한 문자열을 다시 입력하는 것이 귀찮은 일이 되어 버린다. 입력 실수가 발생하더라도 눈으로 모든 내용을 보고 확인할 수 밖에 없어 위험이 높아진다.

다음 요구사항이 있다고 가정하자. 이 과정으로 테이블 설계를 해본다. 테이블 설계에 도입해 나가는 작업을 데이터 모델링이라고 한다.

- 직원은 고유의 사원 번호를 가진다.
- 같은 이름의 사원이 있는 경우가 있다.
- 이름의 한자가 다르다 해도 발음이 같은 직원이 있는 경우가 있다.
- 직원은 메일 주소가 부여된다. 메일 주소는 중복되지 않는다.
- 경력 사원 등 수속 절차에 따라 메일 주소의 부여가 지연될 수 있으며, 이 경우는 당분간 메일 주소가 없는 상태가 된다.
- 직원은 어느 부서에 반드시 소속된다.
- 부서 이름이 중복될 수 없다.
- 부서 전화번호가 가지각색이므로 이것도 관리하고 싶다.

테이블은 행과 열로 구성되는데 행에는 직원을 넣고 열에는 키워드를 모아 둔다. 테이블 설계에서 행을 고유하게 식별하기 위해 식별자를 도입하는 것이 일반적이다. 이것을 기본 키라고 하며, 기본 키가 없을 경우 어떤 레코드에 문제가 있는지를 확인할 경우에 해당 레코드가 단지 하나뿐이라고 보증할 수 없다.

| emp_id | emp_name | emp_roman | emp_email | dept_name | dept_tel |
| --- | --- | --- | --- | --- | --- |
| 1 | 기리조 | Krijo | Krijo@... | 인사부 | 03-12 |
| 2 | 유카리 | Yukari | Yukari@.. | 인사부 | 03-12 |
| 3 | 치에 | Chie | Chie@... | 경리부 | 03-34 |

이 테이블의 문제점은 같은 값을 가지는 부서 이름, 부서 전화번호가 곳곳에 나온다는 것이다. 중복이 수십 개에 달하고 앞으로 어떻게 될지가 잘 안보이면 동일한 문자열을 다시 입력하는 것이 귀찮은 일이 되어 버린다. 입력 실수가 발생하더라도 눈으로 모든 내용을 보고 확인할 수 밖에 없어 위험이 높아진다.

## 포인트 1: 테이블 관계를 도입

회사의 부서에는 여러 사원이 근무하고 있기 때문에 사원 번호를 키로하여 부서의 정보를 갖는 경우, 레코드가 중복된 정보를 갖게된다. 중복 정보를 포함하는 것은 수정할 때 미처 바꾸지 못한 부분이 남아있게 되는 경우가 많다. 즉, 한 개의 테이블에 전부를 갖는다는 방법은 잘못된 것이다.

그래서 직원은 직원, 부서는 부서로 별도의 테이블에서 관리하는 방법을 사용한다. 새로 테이블을 만들어 부서의 정보만을 갖는 테이블을 만든다.

| emp_id | emp_name | emp_roman | emp_email | dept_name | dept_id |
| --- | --- | --- | --- | --- | --- |
| 1 | 기리조 | Krijo | Krijo@... | 인사부 | 100 |
| 2 | 유카리 | Yukari | Yukari@.. | 인사부 | 100 |
| 3 | 치에 | Chie | Chie@... | 경리부 | 101 |

| dept_id | dept_name | dept_tel |
| --- | --- | --- |
| 100 | 인사부 | 03-12 |
| 101 | 경리부 | 03-34 |

모든 것을 emp 테이블에서 관리할 때는 부서 이름에 오타가 있거나 전화번호가 다른것을 감지할 수 없었다. dept 테이블에서 dept_id와 dept_name 또는 dept_tel도 동일한 것이 보장된다. 따라서 입력 실수가 일어날 가능성이 크게 줄어든다.

### 참조 무결성 제약

지금 작업으로 emp 테이블로 등록이 상당히 편해지게 되었다. 그러나 직원이 소속된 부서 코드가 잘못되지 않았다는 것을 어떻게 보장할까? 번호 입력 시 100을 입력해야 하는데 1,000을 잘못 입력할 가능성이 충분히 있을 수 있다. 테이블에서 참조 무결성 제약을 사용하면 emp 테이블에서 dept_id를 입력할 때 dept 테이블에 있는지에 대한 여부를 자동으로 체크한다. 값이 존재하지 않으면 부서 정보가 없는 코드를 입력하려고 했다는 오류가 반환된다.

하지만 참조 무결성 제약으로 모든 것을 해결할 수 없는데, 입력 실수로 인사부(100) 대신 회계 부서(101)로 부서의 정보를 입력하면 그대로 저장된다. 이러한 입력 실수를 방지하려면 애플리케이션 쪽에서 입력 확인을 눈을 확인하거나 체크 디지트를 도입하여 잘못된 값을 검출하는 애플리케이션 측면에서의 대처가 필요하다.

## 포인트 2: 테이블 설계의 타당성 검증하기

현재 테이블은 다음과 같은 단점이 있다. 한 직원당 등록할 수 있는 부서 ID가 하나밖에 없어 두 개 이상 등록하고 싶어도 할 수 없다. 이 방법을 해결할 방법 중 하나는, 새로 겸임이 필요한 직원 ID를 새롭게 만드는 방법이 있다. 개발 부서에는 직원 ID = 123, 지원 부서에 있을 때는 ID=145 와 같은 방식이다. 이 방법에는 단점이 있는데, 먼저 emp 테이블에서 동일 인물로 기본 키가 서로 다른 복수의 레코드가 존재하게 된다. 따라서 같은 이름과 이메일 주소의 레코드가 복수로 나오게 되고, 이는 데이터베이스 구조적으로도 좋다고 말할 수 없다.

### 연속적인 번호의 열 도입하기

현재 emp 테이블에는 부서를 관리하는 열이 한 개밖에 없다. 이에 대해 “메인 소속 부서”, “서브 소속 부서1”, “서브 소속 부서2”와 같이 부서에 대한 열을 여러 개 준비하는 접근 방식일 수 있다. 세 개의 열을 준비하면 최대 세 개 부서까지 겸무 정보를 등록할 수 있다. 하지만 겸임 수가 더 많은 직원이 존재할수록 열 개수가 지나치게 증가하므로 낭비가 심해진다.

| emp_id | emp_name | emp_roman | emp_email | dept_name | dept_id | dept_id2 | dept_id3 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 기리조 | Krijo | Krijo@... | 인사부 | 100 | NULL | NULL |
| 2 | 유카리 | Yukari | Yukari@.. | 인사부 | 100 | NULL | NULL |
| 3 | 치에 | Chie | Chie@... | 경리부 | 101 | 101 | NULL |

| dept_id | dept_name | dept_tel |
| --- | --- | --- |
| 100 | 인사부 | 03-12 |
| 101 | 경리부 | 03-34 |

또한 다음과 같이 하나의 열(dept_id)에 여러 부서의 정보를 등록하는 것도 데이터베이스 구현 측면에 단점이 있다. 여러 값을 정수로 취급한 때는 SET 형인 집합형을 도입해야 한다. 하지만 SET 형식을 지원되지 않는 데이터베이스도 있고 SET형 자체가 검색 조건(인덱스)로서 사용하기 어렵다.

| emp_id | emp_name | emp_roman | emp_email | dept_name | dept_id |
| --- | --- | --- | --- | --- | --- |
| 1 | 기리조 | Krijo | Krijo@... | 인사부 | 100 |
| 2 | 유카리 | Yukari | Yukari@.. | 인사부 | 100 |
| 3 | 치에 | Chie | Chie@... | 경리부 | 100, 101 |

### 1:N 관계를 두 개 도입하기

데이터베이스 설계상 아름다운 모델이 되게 하려면 1:N 관계를 하나 더 도입하면 좋다. 겸임 정보는 사원 ID, 부서ID가 정해지면 고유의 의미를 갖게된다. emp_id와 dept_id라는 ID 밖에 없는 테이블을 보면 필요가 없는 것처럼 보일지도 모른다. 그러나 이 테이블이 없으면 직원이 어느 부서에 소속되어 있는지를 바로 알 수 없고, 부서 안에 어떤 직원이 있는지도 바로 알 수 없다.

| emp_id | dept_id |
| --- | --- |
| 1 | 100 |
| 2 | 100 |
| 3 | 100 |
| 3 | 101 |

| emp_id | emp_name | emp_roman | emp_email |
| --- | --- | --- | --- |
| 1 | 기리조 | Krijo | Krijo@... |
| 2 | 유카리 | Yukari | Yukari@.. |
| 3 | 치에 | Chie | Chie@... |

| dept_id | dept_name | dept_tel |
| --- | --- | --- |
| 100 | 인사부 | 03-12 |
| 101 | 경리부 | 03-34 |

이러한 테이블을 매핑 테이블이라고 한다. 매핑 테이블은 데이터 모델링 과정에서 자주 나온다. 매핑 텥이블의 특징은 다음과 같다.

### 기본 키 값이 자주 바뀐다

“기본 키 값이 변경되어서는 안된다”라고 했지만, 매핑 테이블은 전근 등이 발생했을 때 기본 키 값이 변경된다. 또한 겸임 위치가 변경될 때 새로운 열을 등록하는 대신 겸임 시작일, 겸임 종료일이라는 문자열을 추가하여 기본 키를 변경하지 않는 형태도 있다.

### 레코드 수가 많아진다

매핑 테이블의 레코드 수는 매핑의 소수 테이블보다 많다. 수많은 레코드는 수백 GB(또는 TB) 단위로 늘어나기 때문에 성능을 제대로 내지 못할 수 있다. 한 개의 서버 시스템으로는 데이터의 양이 너무 많아 다 수용할 수 없을 경우에는 테이블을 분할하여 복수의 시스템에서 갖고 있도록하는 방식이 사용될 수 있다.

---

## 이상현상과 정규화
잘못 설계된 테이블로 삽입, 삭제, 수정 같은 작업을 하면 이상현상이 일어난다. 이는 데이터베이스의 일관성을 훼손하여 데이터의 무결성을 깨뜨리는데, 이와같은 문제를 해결하기 위해 몇가지 규칙에 따라 테이블을 분해해야 하고, 잘못된 테이블을 수정하는 과정을 정규화라고 한다.

### 이상현상
이상현상이란 테이블에 투플을 삽입할 때 부득이하게 NULL값이 입력되는경우, 삭제될 때 연쇄삭제가 발생하는 경우, 수정시 데이터의 일관성이 훼손되는 경우를 말한다. <br>
테이블에서 필요한 정보를 찾을때는 문제가 없지만, 삭제, 삽입, 수정과 같이 저장된 내용을 조작할때 문제가 발생한다

#### 삭제이상
어떠한 정보를 삭제하기 위해 한 투플을 삭제하였을때, 의도와 달리 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상으로 연쇄삭제 문제가 발생한다<br>
ex) 삭제 전에 조회할 수 있던 정보를 조회할 수 없게 된 경우

#### 삽입이상
어떠한 정보를 삽입하기 위해 한 투플을 삽입할때 특정 속성에 해당하는 값이 없어 NULL값을 입력해야되는 상황이 일어나는 현상으로 NULL값 문제가 발생한다 <br>
ex) NULL값이 포함된 테이블에 집계 함수를 사용하는 경우

#### 수정이상
투플 수정시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상으로 불일치 문제가 발생한다. <br>
ex) UPDATE문은 조건에 맞는 값을 일괄 수정하지만 조건을 잘못주어 데이터 불일치 문제가 발생하는 경우

### 함수 종속성
이상현상이 발생하는 테이블을 수정하는 과정을 정규화라고 하는데, 정규화를 하기 위해 테이블을 분석하여 키본키와 함수 종속성을 파악해야 한다 <br>

릴레이션의 각 속성 사이에 의존성이 존재하는 예는 강좌 이름을 알때 강의실을 바로 알수 있는것과 같은 경우와 같이 어떤 속성 A의 값을 알면 다른 속성 B의 값이 유일하게 정해지는 의존 관계를 '속성 B는 속성 A에 종속한다' 또는 '속성 A는 속성 B를 결정한다'라고 한다. 이를 'A->B'로 표기한다. <br>

결정자가 복합 속성일 수 있다. ex) 학생번호와 강좌 이름을 알아야 성적을 알 수 있을때

함수 종속성을 판단할때는 릴레이션의 현재 인스턴스(데이터)만을 가지고 판단하지 않고, 속성이 갖는 의미를 가지고 판단해야 한다. <br>

#### 함수 종속성과 기본키
함수 종속성을 파악하기 위해 우선 기본키를 찾아야 한다. 키본키가 함수 종속성에서 어떤 역할을 하는지를 파악한다.
> 기본키는 릴레이션의 모든 속성에 대해 결정자이다. (하나의 기본키 값에 대하여 두개 이상의 투플이 존재하지 않는다)
> 이상현상은 기본키가 아니면서 결정자인 속성이 있을때 발생한다

### 정규화
이상현상의 대부분은 두 가지 이상의 정보가 한 릴레이션에 저장되어 있기 때문에 발생한다. 그러므로 릴레이션을 분해하여 이상현상을 제거한다. 이를 정규화 라고 한다.

#### 제 1정규형
릴레이션의 속성 값이 원자 값이어야 한다. 즉 속성값으로 두개의 값을 가지지 않아야 한다.

#### 제 2정규형
기본키가 복합키일때 복합키의 일부분이 다른 속성의 결정자인지 판단한다.
릴레이션이 제 1정규형이고 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때 제 2 정규형이라고 한다. <br>
ex) 기본키가 (학생번호, 강좌이름)인데, 기본키의 일부인 강좌이름이 강의실을 결정하는 종속관계를 가지고 있을때 이상현상이 발생한다. 제 2 정규형으로 변환 하기 위해서는 이상현상을 일으키는 (강좌이름 -> 강의실)을 분해한다.

#### 제 3정규형
속성들이 이행적으로 종속되어 있는지 여부를 판단한다.
릴레이션이 제 2정규형이고 기본키가 아닌 속성이 기본키에 비이행적으로 종속할때 제 3정규형이라고 한다. (이행적 종속이란 A->B, B->C가 성립할때 A->C가 성립되는 함수 종속성을 말한다)
ex) 학생번호, 강좌이름, 수강료가 있을때 (학생번호->강좌이름->수강료) 이상현상은 릴레이션의 기본키가 아닌 강좌이름이 수강료를 결정하는 종속관계에서 발생한다. (학생번호->강좌이름), (강좌이름->수강료)로 수강료는 기본키에 이행적으로 종속되어 있다.

#### BCNF
릴레이션에 존재하는 함수 종속성에서 모든 결정자가 후보키이면 BCNF정규형이다. (함수 종속성 X->Y가 성립할때 모든 결정자 X가 후보키일때) <br>
ex) (학생번호, 특강이름, 교수)릴레이션이 있을때, 한 학생은 한개이상의 특강이 가능하고, 교수는 한 특강만 담당할때 릴레이션의 기본키가 아닌 교수가 특강이름을 경정하는 종속관계에서 이상현상이 발생한다. 이와 같이 결정자이면서 후보키가 아닌 속성이 존재하면 이상현상이 발생한다.

### 무손실 분해
분해된 릴레이션 간의 관계를 유지하기 위해 분해된 릴레이션에 공통 속성을 한개 이상 두어야 한다. 공통 속성은 분해된 릴레이션을 합성(조인)할때 사용한다.
> 공통된 속성이 릴레이션 R1의 키이거나 혹은 릴레이션 R2의 키여야 한다. (R1,R2 로 분해 되었을때)

### 제 1 정규형

테이블 구성에서 중복, 반복, 복합값 등을 포함한 구조를 제 1정규형이 아닌 테이블이라고 한다. 중복한 열 값의 일부를 수정해도 자동으로 감지할 수 없다.

| emp_id | emp_name | emp_roman | emp_email | dept_name | dept_id |
| --- | --- | --- | --- | --- | --- |
| 1 | 기리조 | Krijo | Krijo@... | 인사부 | 100 |
| 2 | 유카리 | Yukari | Yukari@.. | 인사부 | 100 |
| 3 | 치에 | Chie | Chie@... | 경리부 | 100, 101 |

### 제 2 정규형

기본 키가 여러 열로 구성되어 있고 그 중 일부 열의 값에 의해서만 결정되는 열이 있는 경우, 해당 테이블을 제 2 정규형이 아닌 테이블이라고 부른다.

| emp_id(PK) | dept_id(PK) | dept_name | created |
| --- | --- | --- | --- |
| 1 | 100 | 인사부 | 2010-01-01 |
| 2 | 100 | 인사부 | 2010-01-01 |

위 그림의 경우 created열은 emp_id, dept_id의 두 가지 사항을 모르면 특정할 수 없지만, dept_name 열은 dept_id만 정해지면 확인할 수 있기 때문에 이 테이블에 속하는 것이 적절하지 않다. 또한 같은 dept_id인데도 부서명이 다른 레코드가 등록될 가능성이 있다.

### 제 3 정규형

원칙적으로 테이블의 모든 열은 기본 키 값에 따라 단 하나로 결정되어야 한다. 그렇지 않으면 레코드 간의 일관성이 없는 상태가 되는 등 문제를 야기할 수 있다.

| emp_id(PK) | dept_id | dept_name |
| --- | --- | --- |
| 1 | 100 | 인사부 |
| 2 | 100 | 인사부 |

dept_id는 기본 키는 아니지만, dept_name은 dept_id에 따라 결정되므로 기본 키인 emp_id와 관련이 없다. 이것은 같은 dept_id임에도 불구하고 다른 dept_name을 등록할 수 있는 문제를 야기한다. 이러한 열을 포함하는 테이블 관계를 제 3 정규형이 아니다 라고 말한다.
# 데이터베이스

---
## 데이터베이스가 없으면 무엇이 곤란한가?

1. 대량의 데이터 중에서 필요한 것을 빨리 반환할 수 없다.
2. 대량의 데이터를 메모리 내에서만으로 취급할 수 없다.
3. 장애가 발생했을 때 빠른 복구가 어렵다.
4. 병렬성 제어가 어렵다.
5. 데이터 무결성을 보장하는 것이 어렵다.

---

## 인덱스

### 인덱스와 B-tree
데이터베이스에서 인덱스란 원하는 데이터를 빨리 찾기 위해 투플의 키 값에 대한 물리적 위치를 기록해둔 자료구조

#### B-tree
- 데이터의 검색 시간을 단축하기 위한 자료구조 
- 루트노드, 내부노드, 리프노드로 구성되어 리프노드가 모두 같은 레벨에 존재하는 균형트리 
- 하나의 노드에 여러개가 배치될 수 있다. 
- 각 노드는 키 값과 포인터를 가지며, 키 값은 오름차순으로 저장되어 있고 키 값 좌우에 있는 포인터는 각각 키 값보다 작은 값과 큰 값을 가진 다음 노드를 가리킨다. 
- 모든 검색은 루트 노드에서부터 시작하여 내부 노드를 지나 리프 노드까지 내려가면서 이루어진다. 
- 키 값이 새로 추가되거나 삭제될 경우 동적으로 노드를 분할하거나 통합하여 항상 균형 상태를 유지한다. 
- 삽입될 위치의 노드에 저장할 공간이 없으면 새로운 노드를 분할하여 이동하여 삽입한다.
- B-tree의 삽입과정 [https://www.youtube.com/watch?v=MpYRkCsP2PQ](https://www.youtube.com/watch?v=MpYRkCsP2PQ)
- 데이터의 변경이나 추가가 잦을 경우 노드의 분할 및 이동이 자주 발생하는 문제가 생긴다.

#### 인덱스의 특징
- 인덱스는 테이블에서 한 개 이상의 속성을 이용하여 생성한다.
- 빠른 검색, 효율적인 레코드 접근이 가능하다.
- 순서대로 정렬된 속성과, 데이터의 위치만 보유하므로 테이블보다 작은 공간 차지
- 일반적으로 B-tree형태

### MySQL 인덱스
MySQL의 인덱스는 클러스터 인덱스와 보조 인덱스로 나누어지며 모두 B-tree 인덱스를 기본으로 한다. <br>
클러스터 인덱스는 연속된 키 값의 레코드를 묶어서 같은 블록에 저장하는 방법으로 테이블당 하나만 생성할 수 있고, B-tree 인덱스의 리프노드에서 페이지의 주소 값 대신 테이블의 열 자체가 저장된다. <br>
보조 인덱스는 속성의 값으로 B-tree 인덱스를 구성하며 리프 노드의 각 행은 해당 페이지의 주소값을 저장한다.

#### 클러스터 인덱스
클러스터 인덱스는 인덱스의 리프 노드들이 정렬된 상태로 저장된 테이블 자체. <br>
키 값에 의한 동등 및 범위(BETWEEN) 검색 모두 유리하다.
인덱스 페이지가 단순해져 인덱스 저장시 차지하는 공간도 작다. <br>
테이블 생성시 기본키를 생성하면 자동으로 생성된다. <br>

#### 보조 인덱스
리프노드는 테이블상의 데이터 위치를 지정하는 rowid를 저장한다. <br>
rowid는 (Block번호, Block내의 Row가 위치한 순번)의 형태로 구성되어 있어서 자료가 무작위로 저장되어 있어도 쉽게 찾을 수 있다. <br>
컬럼 하나만을 대상으로 단일 컬럼 인덱스뿐만 아니라, 여러 개의 컬럼을 복합적으로 결합하여 사용하는 인덱스도 만들 수 있다. <br>
검색할 경우 특정 키 값을 찾는 검색의 경우는 성능을 보장할 수 있으나, 범위 검색은 데이터가 저장된 block 값들의 저장 순서가 일정하지 않을 수 있어서 빠른 검색 효과를 보장할 수 없다.

#### MySQL 인덱스
클러스터 인덱스와 보조 인덱스는 보통 같이 사용된다. <br>
예를 들어 id를 클러스터 인덱스로, name을 보조 인덱스로 사용하여 id를 검색할 경우 클러스터 인덱스를 이용하고, name을 검색할 경우 보조 인덱스를 이용하여 id를 찾은 다음 다시 id에 대해 클러스터 인덱스를 사용한다. 이렇게 하는 이유는 클러스터 인덱스로 저장된 데이터의 순서를 가능한 유지하면서 데이터의 삽입과 삭제에 대한 인덱스 관리 비용을 줄이기 위해서이다. <br>
기본키를 지정하면 기본 키에 대하여 클러스터 인덱스를 생성하고, 기본키를 생성하지 않으면 먼저 나오는 UNIQUE 속성에 대하여 클러스터 인덱스를 생성한다. 기본키나 UNIQUE 속성이 없는 테이블은 MySQL이 자체 생성한 행번호를 이용하여 클러스터 인덱스를 생성한다. <br>
클러스터 인덱스가 아닌 모든 인덱스는 보조 인덱스이며 보조 인덱스의 각 레코드는 보조 인덱스 속성과 기본키 속성 값을 갖고 있다. <br>
MySQL이 생성된 인덱스를 활용하여 SQL문을 처리하는지 확인하려면 MySQL Work bench의 실행 계획에서 인덱스를 활용하여 출력하는 과정을 볼 수 있다. <br>

#### 인덱스 생성
인덱스 생성시 고려사항
1) WHERE절에 자주 사용되는 속성이어야 한다
2) 조인에 자주 사용되는 속성이어야 한다
3) 단일 테이블에 인덱스가 많으면 속도가 느려질 수 있다 (테이블당 4~5개 정도 권장)
4) 속성이 가공되는 경우 사용하지 않는다
5) 속성의 선택도가 낮을 때 유리하다 (속성의 모든 값이 다른 경우)

<br>
인덱스 생성 문법 <br>

```sql
CREATE [UNIQUE] INDEX [인덱스이름] ON 테이블이름 (컬럼 [ASC | DESC] [{, 컬럼 [ASC | DESC]} ...])[;]
```

<br>
인덱스 재구성 문법 <br>
B-tree 인덱스는 데이터의 수정, 삭제, 삽입이 잦으면 노드의 갱신이 주기적으로 일어나 단편화 현상이 나타나는데, 이럴 경우 ANALYZE 문법을 통해 인덱스를 다시 생성해준다. <br>

```sql
ANALYZE TABLE 테이블이름;
```

<br>
인덱스 삭제 문법 <br>

```sql
DROP INDEX  인덱스이름 ON 테이블이름;
```

--- 
# 데이터베이스

---
## 데이터베이스가 없으면 무엇이 곤란한가?

1. 대량의 데이터 중에서 필요한 것을 빨리 반환할 수 없다.
2. 대량의 데이터를 메모리 내에서만으로 취급할 수 없다.
3. 장애가 발생했을 때 빠른 복구가 어렵다.
4. 병렬성 제어가 어렵다.
5. 데이터 무결성을 보장하는 것이 어렵다.

---

## 인덱스

### 인덱스와 B-tree
데이터베이스에서 인덱스란 원하는 데이터를 빨리 찾기 위해 투플의 키 값에 대한 물리적 위치를 기록해둔 자료구조

#### B-tree
- 데이터의 검색 시간을 단축하기 위한 자료구조 
- 루트노드, 내부노드, 리프노드로 구성되어 리프노드가 모두 같은 레벨에 존재하는 균형트리 
- 하나의 노드에 여러개가 배치될 수 있다. 
- 각 노드는 키 값과 포인터를 가지며, 키 값은 오름차순으로 저장되어 있고 키 값 좌우에 있는 포인터는 각각 키 값보다 작은 값과 큰 값을 가진 다음 노드를 가리킨다. 
- 모든 검색은 루트 노드에서부터 시작하여 내부 노드를 지나 리프 노드까지 내려가면서 이루어진다. 
- 키 값이 새로 추가되거나 삭제될 경우 동적으로 노드를 분할하거나 통합하여 항상 균형 상태를 유지한다. 
- 삽입될 위치의 노드에 저장할 공간이 없으면 새로운 노드를 분할하여 이동하여 삽입한다.
- B-tree의 삽입과정 [https://www.youtube.com/watch?v=MpYRkCsP2PQ](https://www.youtube.com/watch?v=MpYRkCsP2PQ)
- 데이터의 변경이나 추가가 잦을 경우 노드의 분할 및 이동이 자주 발생하는 문제가 생긴다.

#### 인덱스의 특징
- 인덱스는 테이블에서 한 개 이상의 속성을 이용하여 생성한다.
- 빠른 검색, 효율적인 레코드 접근이 가능하다.
- 순서대로 정렬된 속성과, 데이터의 위치만 보유하므로 테이블보다 작은 공간 차지
- 일반적으로 B-tree형태

### MySQL 인덱스
MySQL의 인덱스는 클러스터 인덱스와 보조 인덱스로 나누어지며 모두 B-tree 인덱스를 기본으로 한다. <br>
클러스터 인덱스는 연속된 키 값의 레코드를 묶어서 같은 블록에 저장하는 방법으로 테이블당 하나만 생성할 수 있고, B-tree 인덱스의 리프노드에서 페이지의 주소 값 대신 테이블의 열 자체가 저장된다. <br>
보조 인덱스는 속성의 값으로 B-tree 인덱스를 구성하며 리프 노드의 각 행은 해당 페이지의 주소값을 저장한다.

#### 클러스터 인덱스
클러스터 인덱스는 인덱스의 리프 노드들이 정렬된 상태로 저장된 테이블 자체. <br>
키 값에 의한 동등 및 범위(BETWEEN) 검색 모두 유리하다.
인덱스 페이지가 단순해져 인덱스 저장시 차지하는 공간도 작다. <br>
테이블 생성시 기본키를 생성하면 자동으로 생성된다. <br>

#### 보조 인덱스
리프노드는 테이블상의 데이터 위치를 지정하는 rowid를 저장한다. <br>
rowid는 (Block번호, Block내의 Row가 위치한 순번)의 형태로 구성되어 있어서 자료가 무작위로 저장되어 있어도 쉽게 찾을 수 있다. <br>
컬럼 하나만을 대상으로 단일 컬럼 인덱스뿐만 아니라, 여러 개의 컬럼을 복합적으로 결합하여 사용하는 인덱스도 만들 수 있다. <br>
검색할 경우 특정 키 값을 찾는 검색의 경우는 성능을 보장할 수 있으나, 범위 검색은 데이터가 저장된 block 값들의 저장 순서가 일정하지 않을 수 있어서 빠른 검색 효과를 보장할 수 없다.

#### MySQL 인덱스
클러스터 인덱스와 보조 인덱스는 보통 같이 사용된다. <br>
예를 들어 id를 클러스터 인덱스로, name을 보조 인덱스로 사용하여 id를 검색할 경우 클러스터 인덱스를 이용하고, name을 검색할 경우 보조 인덱스를 이용하여 id를 찾은 다음 다시 id에 대해 클러스터 인덱스를 사용한다. 이렇게 하는 이유는 클러스터 인덱스로 저장된 데이터의 순서를 가능한 유지하면서 데이터의 삽입과 삭제에 대한 인덱스 관리 비용을 줄이기 위해서이다. <br>
기본키를 지정하면 기본 키에 대하여 클러스터 인덱스를 생성하고, 기본키를 생성하지 않으면 먼저 나오는 UNIQUE 속성에 대하여 클러스터 인덱스를 생성한다. 기본키나 UNIQUE 속성이 없는 테이블은 MySQL이 자체 생성한 행번호를 이용하여 클러스터 인덱스를 생성한다. <br>
클러스터 인덱스가 아닌 모든 인덱스는 보조 인덱스이며 보조 인덱스의 각 레코드는 보조 인덱스 속성과 기본키 속성 값을 갖고 있다. <br>
MySQL이 생성된 인덱스를 활용하여 SQL문을 처리하는지 확인하려면 MySQL Work bench의 실행 계획에서 인덱스를 활용하여 출력하는 과정을 볼 수 있다. <br>

#### 인덱스 생성
인덱스 생성시 고려사항
1) WHERE절에 자주 사용되는 속성이어야 한다
2) 조인에 자주 사용되는 속성이어야 한다
3) 단일 테이블에 인덱스가 많으면 속도가 느려질 수 있다 (테이블당 4~5개 정도 권장)
4) 속성이 가공되는 경우 사용하지 않는다
5) 속성의 선택도가 낮을 때 유리하다 (속성의 모든 값이 다른 경우)

<br>
인덱스 생성 문법 <br>

```sql
CREATE [UNIQUE] INDEX [인덱스이름] ON 테이블이름 (컬럼 [ASC | DESC] [{, 컬럼 [ASC | DESC]} ...])[;]
```

<br>
인덱스 재구성 문법 <br>
B-tree 인덱스는 데이터의 수정, 삭제, 삽입이 잦으면 노드의 갱신이 주기적으로 일어나 단편화 현상이 나타나는데, 이럴 경우 ANALYZE 문법을 통해 인덱스를 다시 생성해준다. <br>

```sql
ANALYZE TABLE 테이블이름;
```

<br>
인덱스 삭제 문법 <br>

```sql
DROP INDEX  인덱스이름 ON 테이블이름;
```

--- 

## 인덱스로 고속 액세스 실현하기

### 전체 검색은 대량의 데이터에 적합하지 않다

사용자 정보를 텍스트 파일로 관리하는 경우, 확인을 위해 파일을 처음부터 찾을 때까지 탐색해야 한다. 이 선형 검색은 검색 알고리즘에서 가장 비효율적인 것이고 적절한 방법이 아니다.

### 원하는 위치까지 순식간에 도달하는 방법 생각하기

고정 길이 파일로 관리하면 특정 위치로 이동하는 작업이 순식간에 가능하지만, 빈 공간의 데이터가 많아져 낭비가 심한 방식이다.

### 해시 인덱스

키 값의 데이터 항목은 숫자, 문자열, 날짜/시간 등 이므로 범용성을 생각하면 고정 길이가 어렵다. 데이터베이스 구현은 키 값을 해시함수에 대입하여 해시 값과 값의 쌍을 갖는 구조로 사용한다. 이러한 인덱스를 해시 인덱스라고 한다. 해시 값은 동일한 크기이므로 고정 길이 포맷으로 대응할 수 있고, 해시 계산 비용은 데이터의 양이 늘어도 변하지 않는다.

해시 인덱스를 구현할 때 다른 키 값인데 해시 값이 동일하게 되는 해시의 충돌이 있는데, 데이터베이스에서는 이를 방지하는 기능을 가지고 있어 데이터의 양이 증가하면 평균 처리 속도는 증가하지만, 전체 검색과는 비교도 안 될 정도로 고속이다.

### 해시 인덱스는 만능이 아니다

데이터베이스에서 다음과 같은 처리는 수시로 이뤄지는데, 해시 인덱스를 다음 목적으로 사용할 수 없다.

1. 가격이 10,000원 이하의 선물을 찾고 싶다.
2. 제목이 “Final”로 시작하는 게임 리스트를 찾고 싶다.
3. 일기 포스팅 시간이 최신 순으로 정렬하고 싶다.

해시 인덱스는 지정한 키 값과 같은 것밖에 찾을 수 없기 때문에 이러한 목적으로 사용할 수 없다. 위 용도로 빠르게 결과를 반환하는 방법은 B+Tree 인덱스 구조를 사용하는 것이다.

---

## 인덱스의 기본 B+Tree 인덱스

### B+Tree 인덱스란?

B+Tree는 루트 블록, 브랜치 블록, 리프 블록이 들어간다. 루트 블록과 브랜치 블록은 검색의 키인 사용자 ID에 대해 해당 블록이 어디에 있는지에 대한 정보를 가지고 있다. 최하층 리프 블록은 실제 저장 위치의 정보를 가지고 있다. 인덱스 검색 시 루트 → 브랜치 → 리프 순으로 도달하여 원하는 데이터를 얻을 수 있다.

![B+Tree 검색](images/B+Tree%20Search.png "B+Tree 검색")

위 예에서 루트를 읽음으로써 브랜치2를 읽으면 되는 것을 알 수 있고, 리프 170을 읽으면 되는 것을 알 수 있다. 루트 1회, 분기 1회, 리프 1회, 실제 데이터의 총 4회로 접근해 원하는 사용자 정보를 얻을 수 있다.

### B+Tree와 B-Tree

BTree 인덱스는 여러 종류가 있지만, RDBMS는 끝단의 리브 볼록에서만 값을 관리하는 B+Tree가 가장 많이 사용된다.

B-Tree는 모든 값을 리프 블록에서만 갖도록 제한하지 않고, 브랜치에서도 값을 가질 수 있는 데이터 구조다.

B+Tree는 B-Tree 보다 브랜치가 컴팩트하므로 인덱스 자체의 계층 구조를 작게 할 수 있다는 장점이 있다. 이는 최악의 경우 액세스 횟수를 줄인다는 것을 의미한다.

보통의 B-Tree는 브랜치에서도 키 정보를 가지고 있다. 따라서 주변의 리프가 아닌 브랜치로 되돌아가 값의 존재 확인을 하고 상위 브랜치로 가거나 다른 리프로 가는 등의 처리를 해야하지만, B+Tree 인덱스는 리프 블록에서 인접한 리프 블록으로 건너는 것만으로 탐색이 가능하기 때문에 더욱 효율적이다.

--- 

## **RDBMS에서는 어떻게 최적화를 실현하고 있는가?**

### 고유성의 보장

인덱스는 고유성을 보장하는 목적으로 사용할 수 있다. 해시 인덱스는 동일 ID인 경우 해시값이 동일하고, B+Tree 인덱스는 동일 리프 블록에 도달하기 때문에 쉽게 중복 체크를 할 수 있다.

고유성이 보장된 인덱스를 고유 인덱스 보장되지 않은 인덱스를 비고유 인덱스라고 한다. 데이터베이스 서버에서는 고유성을 보장하려는 열에 인덱스를 지정하는 것이 필수 조건으로 되어 있거나 내부적으로 인덱스를 작성하는 것이 대부분이다.

### 멀티 칼럼 인덱스

인덱스 검색을 하는 데 있어 지정하고 싶은 조건이 한 개뿐은 아니다. 예를 들어 “사용자 ID가 100이고 마지막 수정 날짜가 2009년 9월 30일 이전의 것”, 이 경우 사용자 ID와 최종 업데이트 모두 검색하는 것이 효과적이다. 이러한 여러 조건의 인덱스를 멀티 칼럼 인덱스라고 한다.

대부분의 RDBMS는 두 가지 요소를 결합한 인덱스를 만들 수 있고, AND 조건에서 검색을 가속화 할 수 있다.

### 인덱스만을 읽는 검색

인덱스 검색은 먼저 인덱스를 읽은 후에 인덱스가 가리키는 데이터 영역을 읽는 두 단계이다. 인덱스 부분과 데이터 부분은 서로 독립적 영역에 존재해 양쪽을 한 번의 액세스로 단번에 읽을 수 없다.

검색 패턴에 따라 인덱스를 읽는 것만으로 처리가 되는 경우도 있다. 예를 들어 “가격이 10,000원 이하인 상품의 개수를 알고 싶다”의 경우에는 가격 인덱스가 있으면 “가격 ≤ 10,000”의 조건에 맞는 레코드 건수를 열거하는 것만으로 결과를 구하므로 데이터 영역에 액세스 할 필요가 없다. 이렇게 인덱스 영역을 읽는 것만으로 처리를 고속으로 완료하는 것을 Index only read, Convering Index 라고 부른다.

### 인덱스 병합

“부서 코드가 100번 또는 입사 연도가 2010년인 직원을 찾고 싶다”라는 경우 OR 조건의 검색은 하나의 인덱스만으로 검색에 도움이 안된다. 그래서 한 번의 두 개 이상의 인덱스를 동시에 사용하여 각각의 결과에서 원하는 레코드를 꺼내는데 이러한 기능을 인덱스 병합이라고 한다.

인덱스 병합은 각 인덱스에서 각각 검색을 실시해 대상의 행 번호를 추출한다. 그 다음 각 결과의 대해 AND 조건과 OR 조건 등으로 집합 연산을 수행하고, 마지막으로 남은 행 번호에 대해 실제 데이터를 읽어 가는 효율적인 동작을 한다.

---

## 데이터 모델링 기술의 중요성 

애플리케이션을 만들 때 중요한 것이 바로 “어떤 데이터 항목이 필요한가”를 제대로 파악하는 것이다. 항목이 부족하면 나중에 추가할 수도 있지만, 이는 대부분의 경우 애플리케이션의 개선이 필요하고 가동 후에 실시하는 것이 쉽지 않기 때문이다.

어떤 항목이 필요한지를 적절히 결정하는 데에는 “데이터를 어떻게 사용하느냐”라는 “업무 요구사항”이 명확하게 있어야 한다. 기능 추가가 자주 발생하는 애플리케이션에서 데이터 항목을 완벽히 미리 밝혀내는 것은 불가능하기 때문에 나중에 손쉽게 추가할 수 있는 디자인도 중요하다.

- 직원은 고유의 사원 번호를 가진다.
- 같은 이름의 사원이 있는 경우가 있다.
- 이름의 한자가 다르다 해도 발음이 같은 직원이 있는 경우가 있다.
- 직원은 메일 주소가 부여된다. 메일 주소는 중복되지 않는다.
- 경력 사원 등 수속 절차에 따라 메일 주소의 부여가 지연될 수 있으며, 이 경우는 당분간 메일 주소가 없는 상태가 된다.
- 직원은 어느 부서에 반드시 소속된다.
- 부서 이름이 중복될 수 없다.
- 부서 전화번호가 가지각색이므로 이것도 관리하고 싶다.

### 전통적 방법의 테이블 생성

테이블은 행과 열로 구성되는데 행에는 직원을 넣고 열에는 키워드를 모아 둔다. 테이블 설계에서 행을 고유하게 식별하기 위해 식별자를 도입하는 것이 일반적이다. 이것을 기본 키라고 하며, 기본 키가 없을 경우 어떤 레코드에 문제가 있는지를 확인할 경우에 해당 레코드가 단지 하나뿐이라고 보증할 수 없다.

| emp_id | emp_name | emp_roman | emp_email | dept_name | dept_tel |
| --- | --- | --- | --- | --- | --- |
| 1 | 기리조 | Krijo | Krijo@... | 인사부 | 03-12 |
| 2 | 유카리 | Yukari | Yukari@.. | 인사부 | 03-12 |
| 3 | 치에 | Chie | Chie@... | 경리부 | 03-34 |

이 테이블의 문제점은 같은 값을 가지는 부서 이름, 부서 전화번호가 곳곳에 나온다는 것이다. 중복이 수십 개에 달하고 앞으로 어떻게 될지가 잘 안보이면 동일한 문자열을 다시 입력하는 것이 귀찮은 일이 되어 버린다. 입력 실수가 발생하더라도 눈으로 모든 내용을 보고 확인할 수 밖에 없어 위험이 높아진다.

---



# Java

---

## 객체 생성과 파괴
#### 생성자 대신 정적 팩터리 메서드를 고려하라

- 정적 팩터리 매서드 장점
1) 이름을 가질 수 있다.
> 이름을 잘 지으면 반환되는 객체를 쉽게 묘사할 수 있다.
2) 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
> 생성비용이 큰 객체가 자주 요쳥되는 상황일때 성능 향상. Flyweight pattern과 비슷한 기법
> 반복되는 요청에 같은 객체를 반환하는 식으로 인스턴스를 통제할 수 있다.
3) 반환 타입의 하위 타입 객체를 반환할 수 있다.
> 반환할 객체의 클래스를 선택하는 유연성을 제공
4) 입력 매개변수에 따라 매번 다른 클래스의 객체 반환 가능
> EnumSet 클래스는 원소 수에 따라 하위 클래스 RegularEnumSet, JumboEnumSet 중 하나의 인스턴스를 반환
5) 정적 팩터리 매서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

- 정적 팩터리 매서드 단점
1) 정적 팩터리 매서드만 제공하면 하위 클래스를 만들 수 없다.
2) 프로그래머가 메서드를 찾기 어렵다.

- 정적 팩터리 메서드와 public 생성자는 각각 장단점이 있어, 무작정 public 생성자를 사용하는 습관을 고치자

<br>

#### 생성자에 매개변수가 많다면 빌더를 고려하자

- 생성자에 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
- 자바빈즈 패턴에서는 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 일관성이 무너진다.
- 빌더패턴은 매개변수가 4개 이상은 되어야 값어치를 한다.

<br>

#### private 생성자나 열거 타입으로 싱글턴임을 보증하라

<br>


#### 인스턴스화를 막으려면 private 생성자를 사용하라

- 모든 생성자는 명시적이거나 묵시적으로 상위 클래스의 생성자를 호출하므로, 상속을 불가능하게 하는 효과도 있다.

<br>


#### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 클라이언트가 원하는 자원을 사용하기 위한 패턴
- 인스턴스를 생성할때 생성자에 필요한 자원을 넘겨준다
- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 줄때 고려한다.

<br>

--- 

## 람다와 스트림
자바 8에서 함수형 인터페이스, 람다, 메서드 참조가 추가되면서 함수 객체를 더 쉽게 만들 수 있게 되었다. 그리고 스트림 API가 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하기 시작했다.

### 익명 클래스와 람다
자바에서 함수 타입을 표현할 때 추상메서드를 하나만 담은 인터페이스를 사용했었는데, 이 인터페이스의 인스턴스를 함수 객체라고 하여 특정 함수나 동작을 나타내는데 사용했다. 그리고 함수 객체를 만드는 주요 수단은 익명클래스가 되었다. <br>

익명클래스 방식은 코드가 너무 길어서 자바는 함수형 프로그래밍에 적합하지 않았다. 그래서 함수형 인터페이스의 인스턴스를 람다식을 사용해 만들 수 있게 되었다. <br>

ex) 문자열을 길이순으로 정렬하는데 비교함수 <br>

익명 클래스의 인스턴스를 함수 객체로 사용할때
```java
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```

람다식을 함수 객체로 사용할때
```java
Collections.sort(words, (s1,s2) -> Integer.compare(s1.length(), s2.length()) );
```

람다식에서 람다, 매개변수, 반환값 타입이 언급되지 않고 컴파일러가 타입을 추론하지만, 직접 명시할때도 있다. <br>

람다대신 비교자 생성 메서드나 자바8때 List 인터페이스에 추가된 sort 메서드를 이용하며 더 짧게 만들수도 있다. <br>

#### 람다 주의사함

람다는 이름이 없고 문서화도 못해서 코드 동작이 명확하지 않고, 코드 수가 많아지면 람다를 쓰지 말아야 한다. 길면 가독성이 나빠진다. <br>

람다는 함수형 인터페이스에서만 쓰이고, 추상 클래스의 인터페이스를 만들 때 람다를 쓸 수 없고 익명 클래스를 써야한다. 또한 람다에서 this 키워드는 바깥 인스턴스를 가리켜서 자신을 참조할 수 없다. 그러므로 함수 객체가 자신을 참조할때는 익명 클래스를 써야한다.

### 람다와 메서드 참조
함수 객체를 람다보다 더 간결하게 만드는 방법은 메서드 참조이다. 

람다식 예시
```java
(a,b) -> a+b
```

메서드 참조 예시
```java
Integer::sum
```

람다가 너무 길때 메서드 참조가 좋은 방법이된다. 람다로 작성할 코드를 새로운 메서드에 담은 다음, 람다 대신 그 메서드 참조를 사용할 수 있다. <br>
IDE는 람다를 메서드 참조로 대체할것을 권하지만 람다가 메서드 참조보다 간결할때도 있다. (메서드와 람다가 같은 클래스에 있을때) <br>

#### 메서드 참조의 유형

1) 정적 메서드
>
2) 한정적 인스턴스 메서드
>
3) 비한정적 인스턴스 메서드
>
4) 클래스 생성자
>
4) 배열 생성자
> 

---